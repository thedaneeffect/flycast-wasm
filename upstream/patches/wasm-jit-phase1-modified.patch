diff --git a/CMakeLists.txt b/CMakeLists.txt
index 878b5d5..7496f4e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -186,60 +186,88 @@ if(NINTENDO_SWITCH)
 		IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS)
 
 elseif(LIBRETRO)
-	add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
-	if(APPLE)
-		if(NOT IOS)
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
-		endif()
-		set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-exported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/shell/libretro/libretro.osx.def")
+	if(EMSCRIPTEN)
+		# Emscripten: static library (object files archived later for linking with EmulatorJS RetroArch)
+		add_library(${PROJECT_NAME} STATIC core/emulator.cpp)
+		target_compile_definitions(${PROJECT_NAME} PRIVATE
+			LIBRETRO
+			GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
+		target_compile_options(${PROJECT_NAME} PRIVATE -fexceptions)
+		set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro_emscripten")
+		# Disable features incompatible with WASM
+		set(USE_VULKAN OFF CACHE BOOL "Force vulkan off" FORCE)
+		set(USE_DX9 OFF CACHE BOOL "Force DX9 off" FORCE)
+		set(USE_DX11 OFF CACHE BOOL "Force DX11 off" FORCE)
+		set(USE_OPENMP OFF CACHE BOOL "Force OpenMP off" FORCE)
+		set(USE_BREAKPAD OFF CACHE BOOL "Force breakpad off" FORCE)
+		set(USE_LUA OFF CACHE BOOL "Force Lua off" FORCE)
+		set(USE_DISCORD OFF CACHE BOOL "Force Discord off" FORCE)
+		# Use GLES3 path for GL symbol loading
+		set(USE_GLES ON CACHE BOOL "Force GLES for Emscripten" FORCE)
+		# asio: disable threads (WASM is single-threaded)
+		target_compile_definitions(${PROJECT_NAME} PRIVATE
+			ASIO_DISABLE_THREADS
+			ASIO_DISABLE_LOCAL_SOCKETS
+			ASIO_DISABLE_SERIAL_PORT)
 	else()
-		if(NOT CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
-		endif()
-	endif()
-	set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro"
-	  XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
-	  XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY ""
-    )
-	set(CMAKE_SHARED_LIBRARY_PREFIX "")
-	set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-	target_compile_definitions(${PROJECT_NAME} PRIVATE LIBRETRO)
-	if(APPLE)
-		find_library(FOUNDATION Foundation)
-		target_link_libraries(${PROJECT_NAME} PRIVATE ${FOUNDATION})
-	endif()
-	if(ANDROID OR USE_GLES)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
-    elseif(IOS)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3)
-		find_library(OPENGLES OpenGLES)
-		find_library(GLKIT GLKit)
-		target_link_libraries(${PROJECT_NAME} PRIVATE ${OPENGLES} ${GLKIT})
-	elseif(USE_GLES2)
-		target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES2 HAVE_OPENGLES HAVE_OPENGLES2)
-		if(USE_VIDEOCORE)
-			target_compile_definitions(${PROJECT_NAME} PRIVATE TARGET_NO_STENCIL)
-			target_link_libraries(${PROJECT_NAME} PRIVATE "-lbrcmGLESv2")
-			target_link_directories(${PROJECT_NAME} PRIVATE "/opt/vc/lib")
+		add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
+		if(APPLE)
+			if(NOT IOS)
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
+			endif()
+			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-exported_symbols_list,${CMAKE_CURRENT_SOURCE_DIR}/shell/libretro/libretro.osx.def")
 		else()
-			target_link_libraries(${PROJECT_NAME} PRIVATE "-lGLESv2")
-		endif()
-	elseif(USE_OPENGL)
-		if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|OpenBSD|NetBSD")
-			find_package(OpenGL REQUIRED)
-			if(CMAKE_VERSION VERSION_LESS 3.29.0)
-				target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIR})
-			else()
-				target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIRS})
+			if(NOT CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
 			endif()
 		endif()
-		target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OPENGL)
+		set(CMAKE_SHARED_LIBRARY_PREFIX "")
+		target_compile_definitions(${PROJECT_NAME} PRIVATE LIBRETRO)
 		if(APPLE)
-			set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-framework,OpenGL")
-		else()
-			target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OIT)
+			find_library(FOUNDATION Foundation)
+			target_link_libraries(${PROJECT_NAME} PRIVATE ${FOUNDATION})
 		endif()
+		if(ANDROID OR USE_GLES)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3 HAVE_OIT)
+		elseif(IOS)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES3 HAVE_OPENGLES HAVE_OPENGLES3)
+			find_library(OPENGLES OpenGLES)
+			find_library(GLKIT GLKit)
+			target_link_libraries(${PROJECT_NAME} PRIVATE ${OPENGLES} ${GLKIT})
+		elseif(USE_GLES2)
+			target_compile_definitions(${PROJECT_NAME} PRIVATE GLES GLES2 HAVE_OPENGLES HAVE_OPENGLES2)
+			if(USE_VIDEOCORE)
+				target_compile_definitions(${PROJECT_NAME} PRIVATE TARGET_NO_STENCIL)
+				target_link_libraries(${PROJECT_NAME} PRIVATE "-lbrcmGLESv2")
+				target_link_directories(${PROJECT_NAME} PRIVATE "/opt/vc/lib")
+			else()
+				target_link_libraries(${PROJECT_NAME} PRIVATE "-lGLESv2")
+			endif()
+		elseif(USE_OPENGL)
+			if (CMAKE_SYSTEM_NAME MATCHES "FreeBSD|OpenBSD|NetBSD")
+				find_package(OpenGL REQUIRED)
+				if(CMAKE_VERSION VERSION_LESS 3.29.0)
+					target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIR})
+				else()
+					target_include_directories(${PROJECT_NAME} PRIVATE ${OPENGL_INCLUDE_DIRS})
+				endif()
+			endif()
+			target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OPENGL)
+			if(APPLE)
+				set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-framework,OpenGL")
+			else()
+				target_compile_definitions(${PROJECT_NAME} PRIVATE HAVE_OIT)
+			endif()
+		endif()
+	endif()
+	if(NOT EMSCRIPTEN)
+		set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "flycast_libretro"
+		  XCODE_ATTRIBUTE_CODE_SIGNING_ALLOWED "NO"
+		  XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY ""
+		)
+		set(CMAKE_SHARED_LIBRARY_PREFIX "")
 	endif()
+	set(CMAKE_POSITION_INDEPENDENT_CODE ON)
 elseif(ANDROID)
 	add_library(${PROJECT_NAME} SHARED core/emulator.cpp)
 	set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_RELEASE} -O3")
@@ -1333,7 +1361,9 @@ if("x86" IN_LIST ARCHITECTURE OR "x86_64" IN_LIST ARCHITECTURE)
 			core/rec-x64/x64_regalloc.h)
 	endif()
 endif()
-
+if(EMSCRIPTEN)
+	target_sources(${PROJECT_NAME} PRIVATE core/rec-wasm/rec_wasm.cpp)
+endif()
 if((USE_OPENGL OR USE_GLES2 OR USE_GLES) AND NOT LIBRETRO)
 	add_library(glad STATIC core/deps/glad/src/gl.c)
 	if(NOT APPLE AND NOT WIN32 AND NOT SDL2_FOUND)
diff --git a/core/build.h b/core/build.h
index 6ea5355..07c7738 100755
--- a/core/build.h
+++ b/core/build.h
@@ -17,6 +17,7 @@
 #define CPU_ARM      0x20000002
 #define CPU_ARM64    0x20000003
 #define CPU_X64      0x20000004
+#define CPU_GENERIC  0x20000005
 
 //FEAT_SHREC, FEAT_AREC, FEAT_DSPREC
 #define DYNAREC_NONE	0x40000001
@@ -24,7 +25,13 @@
 
 //automatic
 
-#if defined(__x86_64__) || defined(_M_X64)
+#if defined(__EMSCRIPTEN__) || defined(__wasm__)
+	#define HOST_CPU CPU_GENERIC
+	// WASM JIT backend
+	#define FEAT_SHREC DYNAREC_JIT
+	#define FEAT_AREC DYNAREC_NONE
+	#define FEAT_DSPREC DYNAREC_NONE
+#elif defined(__x86_64__) || defined(_M_X64)
 	#define HOST_CPU CPU_X64
 #elif defined(__i386__) || defined(_M_IX86)
 	#define HOST_CPU CPU_X86
@@ -48,7 +55,7 @@
 #endif
 
 #if defined(TARGET_NO_REC)
-#define FEAT_SHREC DYNAREC_NONE
+#define FEAT_SHREC DYNAREC_JIT
 #define FEAT_AREC DYNAREC_NONE
 #define FEAT_DSPREC DYNAREC_NONE
 #endif
@@ -69,7 +76,7 @@
 	#if HOST_CPU == CPU_ARM || HOST_CPU == CPU_ARM64 || HOST_CPU == CPU_X86 || HOST_CPU == CPU_X64
 		#define FEAT_SHREC DYNAREC_JIT
 	#else
-		#define FEAT_SHREC DYNAREC_NONE
+		#define FEAT_SHREC DYNAREC_JIT
 	#endif
 #endif
 
diff --git a/core/hw/mem/addrspace.cpp b/core/hw/mem/addrspace.cpp
index c08cb8e..fd1756b 100644
--- a/core/hw/mem/addrspace.cpp
+++ b/core/hw/mem/addrspace.cpp
@@ -7,6 +7,9 @@
 #include "oslib/oslib.h"
 #include "oslib/virtmem.h"
 #include <cassert>
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 
 namespace addrspace
 {
@@ -410,9 +413,21 @@ void initMappings()
 		WARN_LOG(VMEM, "Warning! nvmem is DISABLED (due to failure or not being built-in");
 
 		// Allocate it all and initialize it.
+#ifdef __EMSCRIPTEN__
+		EM_ASM({ console.log('[rec_wasm] initMappings: allocating Sh4RCB, size=' + $0); }, (int)sizeof(Sh4RCB));
+#endif
 		p_sh4rcb = (Sh4RCB*)malloc_pages(sizeof(Sh4RCB));
+#ifdef __EMSCRIPTEN__
+		EM_ASM({ console.log('[rec_wasm] initMappings: p_sh4rcb=' + $0); }, (int)(uintptr_t)p_sh4rcb);
+#endif
 #if FEAT_SHREC != DYNAREC_NONE
+#ifdef __EMSCRIPTEN__
+		EM_ASM({ console.log('[rec_wasm] initMappings: bm_vmem_pagefill FPCB, size=' + $0); }, (int)sizeof(p_sh4rcb->fpcb));
+#endif
 		bm_vmem_pagefill((void**)p_sh4rcb->fpcb, sizeof(p_sh4rcb->fpcb));
+#ifdef __EMSCRIPTEN__
+		EM_ASM({ console.log('[rec_wasm] initMappings: bm_vmem_pagefill done'); });
+#endif
 #endif
 		memset(&p_sh4rcb->cntx, 0, sizeof(p_sh4rcb->cntx));
 
diff --git a/core/hw/naomi/naomi.cpp b/core/hw/naomi/naomi.cpp
index abebd4e..1c4a1b0 100644
--- a/core/hw/naomi/naomi.cpp
+++ b/core/hw/naomi/naomi.cpp
@@ -1,419 +1,425 @@
-/*
-	This file is part of Flycast.
-
-    Flycast is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 2 of the License, or
-    (at your option) any later version.
-
-    Flycast is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with Flycast.  If not, see <https://www.gnu.org/licenses/>.
- */
-#include "types.h"
-#include "hw/holly/sb.h"
-#include "hw/sh4/sh4_mem.h"
-#include "hw/holly/holly_intc.h"
-#include "hw/sh4/sh4_sched.h"
-#include "hw/hwreg.h"
-
-#include "naomi.h"
-#include "naomi_cart.h"
-#include "naomi_regs.h"
-#include "naomi_m3comm.h"
-#include "serialize.h"
-#include "network/output.h"
-#include "hw/sh4/modules/modules.h"
-#include "oslib/oslib.h"
-#include "printer.h"
-#include "hw/flashrom/x76f100.h"
-#include "midiffb.h"
-#include "atomiswave.h"
-#include "oslib/i18n.h"
-
-#include <algorithm>
-
-static NaomiM3Comm m3comm;
-Multiboard *multiboard;
-
-static X76F100SerialFlash mainSerialId;
-static X76F100SerialFlash romSerialId;
-
-static int dmaSchedId = -1;
-static int dmaXferDelay = 10;	// cart dma xfer speed, in cycles/byte (default 20 MB/s)
-
-void NaomiBoardIDWrite(const u16 data)
-{
-	// bit 2: clock
-	// bit 3: data
-	// bit 4: reset (x76f100 only)
-	// bit 5: chip select
-	mainSerialId.writeCS(data & 0x20);
-	mainSerialId.writeRST(data & 0x10);
-	mainSerialId.writeSCL(data & 4);
-	mainSerialId.writeSDA(data & 8);
-}
-
-u16 NaomiBoardIDRead()
-{
-	// bit 0 indicates the eeprom is a X76F100, otherwise the BIOS expects an AT93C46
-	// bit 3 is xf76f100 SDA
-	// bit 4 is at93c46 DO
-	return (mainSerialId.readSDA() << 3) | 1;
-}
-
-void NaomiGameIDWrite(const u16 data)
-{
-	romSerialId.writeCS(data & 4);
-	romSerialId.writeRST(data & 8);
-	romSerialId.writeSCL(data & 2);
-	romSerialId.writeSDA(data & 1);
-}
-
-u16 NaomiGameIDRead()
-{
-	return romSerialId.readSDA() << 15;
-}
-
-u32 ReadMem_naomi(u32 address, u32 size)
-{
-//	verify(size != 1);
-	if (unlikely(CurrentCartridge == NULL))
-	{
-		INFO_LOG(NAOMI, "called without cartridge");
-		return 0xFFFF;
-	}
-	if (address >= NAOMI_COMM2_CTRL_addr && address <= NAOMI_COMM2_STATUS1_addr)
-		return m3comm.ReadMem(address, size);
-	else
-		return CurrentCartridge->ReadMem(address, size);
-}
-
-void WriteMem_naomi(u32 address, u32 data, u32 size)
-{
-	if (unlikely(CurrentCartridge == NULL))
-	{
-		INFO_LOG(NAOMI, "called without cartridge");
-		return;
-	}
-	if (address >= NAOMI_COMM2_CTRL_addr && address <= NAOMI_COMM2_STATUS1_addr
-			&& settings.platform.isNaomi())
-		m3comm.WriteMem(address, data, size);
-	else
-		CurrentCartridge->WriteMem(address, data, size);
-}
-
-static int naomiDmaSched(int tag, int sch_cycl, int jitter, void *arg)
-{
-	u32 start = SB_GDSTARD;
-	u32 len = std::min<int>(((SB_GDLEN + 31) & ~31) - SB_GDLEND, 1024);
-	SB_GDLEND += len;
-	while (len > 0)
-	{
-		u32 block_len = len;
-		void* ptr = CurrentCartridge->GetDmaPtr(block_len);
-		if (block_len == 0)
-		{
-			INFO_LOG(NAOMI, "Aborted DMA transfer. Read past end of cart?");
-			for (u32 i = 0; i < len; i += 8, start += 8)
-				addrspace::write64(start, 0);
-			break;
-		}
-		WriteMemBlock_nommu_ptr(start, (u32*)ptr, block_len);
-		CurrentCartridge->AdvancePtr(block_len);
-		len -= block_len;
-		start += block_len;
-	}
-	SB_GDSTARD = start;
-	if (SB_GDLEN <= SB_GDLEND)
-	{
-		SB_GDST = 0;
-		asic_RaiseInterrupt(holly_GDROM_DMA);
-		return 0;
-	}
-	else {
-		return std::min<int>(SB_GDLEN - SB_GDLEND, 1024) * dmaXferDelay;
-	}
-}
-
-//Dma Start
-static void Naomi_DmaStart(u32 addr, u32 data)
-{
-	if ((data & 1) == 0 || SB_GDST == 1)
-		return;
-	if (SB_GDEN == 0)
-	{
-		INFO_LOG(NAOMI, "Invalid NAOMI-DMA start, SB_GDEN=0. Ignoring it.");
-		return;
-	}
-	
-	if (multiboard != nullptr && multiboard->dmaStart())
-	{
-	}
-	else if (!m3comm.DmaStart(addr, data) && CurrentCartridge != nullptr)
-	{
-		DEBUG_LOG(NAOMI, "NAOMI-DMA start addr %08X len %x", SB_GDSTAR, SB_GDLEN);
-		verify(1 == SB_GDDIR);
-		SB_GDST = 1;
-		SB_GDSTARD = SB_GDSTAR & 0x1FFFFFE0;
-		SB_GDLEND = 0;
-		// Max G1 bus rate: 50 MHz x 16 bits
-		// SH4_access990312_e.xls: 14.4 MB/s from GD-ROM to system RAM
-		// Here: 20 MB/s
-		sh4_sched_request(dmaSchedId, std::min<int>(SB_GDLEN, 1024) * dmaXferDelay);
-		return;
-	}
-	else
-	{
-		SB_GDSTARD = SB_GDSTAR + SB_GDLEN;
-		SB_GDLEND = SB_GDLEN;
-	}
-	asic_RaiseInterrupt(holly_GDROM_DMA);
-}
-
-void Naomi_setDmaDelay()
-{
-	if (settings.platform.isAtomiswave() || settings.content.gameId == "FORCE FIVE"
-			|| settings.content.gameId == "KENJU")
-		// 7 MB/s for Atomiwave games and conversions
-		dmaXferDelay = 27;
-	else
-		dmaXferDelay = 10;
-}
-
-static void Naomi_DmaEnable(u32 addr, u32 data)
-{
-	SB_GDEN = data & 1;
-	if (SB_GDEN == 0 && SB_GDST == 1)
-	{
-		INFO_LOG(NAOMI, "NAOMI-DMA aborted");
-		SB_GDST = 0;
-		sh4_sched_request(dmaSchedId, -1);
-	}
-}
-
-void naomi_reg_Init()
-{
-	static const u8 romSerialData[0x84] = {
-		0x19, 0x00, 0xaa, 0x55,
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x69, 0x79, 0x68, 0x6b, 0x74, 0x6d, 0x68, 0x6d,
-		0xa1, 0x09, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
-		' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  ' ', ' ', ' ', ' ',
-		'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'
-	};
-	romSerialId.setData(romSerialData);
-	mainSerialId.setData(romSerialData);
-	if (dmaSchedId == -1)
-		dmaSchedId = sh4_sched_register(0, naomiDmaSched);
-}
-
-// Sets the full content of the rom board serial eeprom (132 bytes)
-// including response to reset and read/write passwords.
-void setGameSerialId(const u8 *data)
-{
-	romSerialId.setData(data);
-}
-
-// Return the protected data from the rom board serial eeprom (112 bytes)
-// excluding response to reset and passwords.
-const u8 *getGameSerialId()
-{
-	return romSerialId.getProtectedData();
-}
-
-void naomi_reg_Term()
-{
-	if (multiboard != nullptr)
-		delete multiboard;
-	multiboard = nullptr;
-	m3comm.closeNetwork();
-	networkOutput.term();
-	if (dmaSchedId != -1)
-		sh4_sched_unregister(dmaSchedId);
-	dmaSchedId = -1;
-	midiffb::term();
-}
-
-void naomi_reg_Reset(bool hard)
-{
-	hollyRegs.setWriteHandler<SB_GDST_addr>(Naomi_DmaStart);
-	hollyRegs.setWriteHandler<SB_GDEN_addr>(Naomi_DmaEnable);
-	SB_GDST = 0;
-	SB_GDEN = 0;
-	sh4_sched_request(dmaSchedId, -1);
-
-	atomiswave::reset();
-
-	m3comm.closeNetwork();
-	if (hard)
-	{
-		naomi_cart_Close();
-		if (multiboard != nullptr)
-		{
-			delete multiboard;
-			multiboard = nullptr;
-		}
-		if (settings.naomi.multiboard)
-			multiboard = new Multiboard();
-		networkOutput.reset();
-		mainSerialId.reset();
-		romSerialId.reset();
-	}
-	else if (multiboard != nullptr)
-		multiboard->reset();
-	midiffb::reset();
-}
-
-void naomi_Serialize(Serializer& ser)
-{
-	mainSerialId.serialize(ser);
-	romSerialId.serialize(ser);
-	atomiswave::serialize(ser);
-	// TODO serialize m3comm?
-	midiffb::serialize(ser);
-	sh4_sched_serialize(ser, dmaSchedId);
-}
-void naomi_Deserialize(Deserializer& deser)
-{
-	if (deser.version() < Deserializer::V40)
-	{
-		deser.skip<u32>();	// GSerialBuffer
-		deser.skip<u32>();	// BSerialBuffer
-		deser.skip<int>();	// GBufPos
-		deser.skip<int>();	// BBufPos
-		deser.skip<int>();	// GState
-		deser.skip<int>();	// BState
-		deser.skip<int>();	// GOldClk
-		deser.skip<int>();	// BOldClk
-		deser.skip<int>();	// BControl
-		deser.skip<int>();	// BCmd
-		deser.skip<int>();	// BLastCmd
-		deser.skip<int>();	// GControl
-		deser.skip<int>();	// GCmd
-		deser.skip<int>();	// GLastCmd
-		deser.skip<int>();	// SerStep
-		deser.skip<int>();	// SerStep2
-		deser.skip(69);		// BSerial
-		deser.skip(69);		// GSerial
-	}
-	else
-	{
-		mainSerialId.deserialize(deser);
-		romSerialId.deserialize(deser);
-	}
-	if (deser.version() < Deserializer::V36)
-	{
-		deser.skip<u32>(); // reg_dimm_command;
-		deser.skip<u32>(); // reg_dimm_offsetl;
-		deser.skip<u32>(); // reg_dimm_parameterl;
-		deser.skip<u32>(); // reg_dimm_parameterh;
-		deser.skip<u32>(); // reg_dimm_status;
-	}
-	atomiswave::deserialize(deser);
-	midiffb::deserialize(deser);
-	if (deser.version() >= Deserializer::V45)
-		sh4_sched_deserialize(deser, dmaSchedId);
-}
-
-struct DriveSimPipe : public SerialPort::Pipe
-{
-	void write(u8 data) override
-	{
-		if (buffer.empty() && data != 2)
-			return;
-		if (buffer.size() == 7)
-		{
-			u8 checksum = 0;
-			for (u8 b : buffer)
-				checksum += b;
-			if (checksum == data)
-			{
-				int newTacho = (buffer[2] - 1) * 100;
-				if (newTacho != tacho)
-				{
-					tacho = newTacho;
-					networkOutput.output("tachometer", tacho);
-				}
-				int newSpeed = buffer[3] - 1;
-				if (newSpeed != speed)
-				{
-					speed = newSpeed;
-					networkOutput.output("speedometer", speed);
-				}
-				if (!config::NetworkOutput)
-				{
-					std::string message = strprintf(i18n::T("Speed: %3d"), speed);
-					os_notify(message.c_str(), 1000);
-				}
-			}
-			buffer.clear();
-		}
-		else
-		{
-			buffer.push_back(data);
-		}
-	}
-
-	void reset()
-	{
-		buffer.clear();
-		tacho = -1;
-		speed = -1;
-	}
-private:
-	std::vector<u8> buffer;
-	int tacho = -1;
-	int speed = -1;
-};
-
-void initDriveSimSerialPipe()
-{
-	static DriveSimPipe pipe;
-
-	pipe.reset();
-	SCIFSerialPort::Instance().setPipe(&pipe);
-}
-
-G2PrinterConnection g2PrinterConnection;
-
-u32 G2PrinterConnection::read(u32 addr, u32 size)
-{
-	if (addr == STATUS_REG_ADDR)
-	{
-		u32 ret = printerStat;
-		printerStat |= 1;
-		DEBUG_LOG(NAOMI, "Printer status == %x", ret);
-		return ret;
-	}
-	else
-	{
-		INFO_LOG(NAOMI, "Unhandled G2 Ext read<%d> at %x", size, addr);
-		return 0;
-	}
-}
-
-void G2PrinterConnection::write(u32 addr, u32 size, u32 data)
-{
-	switch (addr)
-	{
-	case DATA_REG_ADDR:
-		for (u32 i = 0; i < size; i++)
-			printer::print((char)(data >> (i * 8)));
-		break;
-
-	case STATUS_REG_ADDR:
-		DEBUG_LOG(NAOMI, "Printer status = %x", data);
-		printerStat &= ~1;
-		break;
-
-	default:
-		INFO_LOG(NAOMI, "Unhandled G2 Ext write<%d> at %x: %x", size, addr, data);
-		break;
-	}
-}
-
+/*
+	This file is part of Flycast.
+
+    Flycast is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 2 of the License, or
+    (at your option) any later version.
+
+    Flycast is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Flycast.  If not, see <https://www.gnu.org/licenses/>.
+ */
+#include "types.h"
+#include "hw/holly/sb.h"
+#include "hw/sh4/sh4_mem.h"
+#include "hw/holly/holly_intc.h"
+#include "hw/sh4/sh4_sched.h"
+#include "hw/hwreg.h"
+
+#include "naomi.h"
+#include "naomi_cart.h"
+#include "naomi_regs.h"
+#include "naomi_m3comm.h"
+#include "serialize.h"
+#include "network/output.h"
+#include "hw/sh4/modules/modules.h"
+#include "oslib/oslib.h"
+#include "printer.h"
+#include "hw/flashrom/x76f100.h"
+#include "midiffb.h"
+#include "atomiswave.h"
+#include "oslib/i18n.h"
+
+#include <algorithm>
+
+static NaomiM3Comm m3comm;
+Multiboard *multiboard;
+
+static X76F100SerialFlash mainSerialId;
+static X76F100SerialFlash romSerialId;
+
+static int dmaSchedId = -1;
+static int dmaXferDelay = 10;	// cart dma xfer speed, in cycles/byte (default 20 MB/s)
+
+// Diagnostic counters for serial EEPROM access tracking
+u32 g_naomi_board_write_count = 0;
+u32 g_naomi_board_read_count = 0;
+
+void NaomiBoardIDWrite(const u16 data)
+{
+	g_naomi_board_write_count++;
+	// bit 2: clock
+	// bit 3: data
+	// bit 4: reset (x76f100 only)
+	// bit 5: chip select
+	mainSerialId.writeCS(data & 0x20);
+	mainSerialId.writeRST(data & 0x10);
+	mainSerialId.writeSCL(data & 4);
+	mainSerialId.writeSDA(data & 8);
+}
+
+u16 NaomiBoardIDRead()
+{
+	g_naomi_board_read_count++;
+	// bit 0 indicates the eeprom is a X76F100, otherwise the BIOS expects an AT93C46
+	// bit 3 is xf76f100 SDA
+	// bit 4 is at93c46 DO
+	return (mainSerialId.readSDA() << 3) | 1;
+}
+
+void NaomiGameIDWrite(const u16 data)
+{
+	romSerialId.writeCS(data & 4);
+	romSerialId.writeRST(data & 8);
+	romSerialId.writeSCL(data & 2);
+	romSerialId.writeSDA(data & 1);
+}
+
+u16 NaomiGameIDRead()
+{
+	return romSerialId.readSDA() << 15;
+}
+
+u32 ReadMem_naomi(u32 address, u32 size)
+{
+//	verify(size != 1);
+	if (unlikely(CurrentCartridge == NULL))
+	{
+		INFO_LOG(NAOMI, "called without cartridge");
+		return 0xFFFF;
+	}
+	if (address >= NAOMI_COMM2_CTRL_addr && address <= NAOMI_COMM2_STATUS1_addr)
+		return m3comm.ReadMem(address, size);
+	else
+		return CurrentCartridge->ReadMem(address, size);
+}
+
+void WriteMem_naomi(u32 address, u32 data, u32 size)
+{
+	if (unlikely(CurrentCartridge == NULL))
+	{
+		INFO_LOG(NAOMI, "called without cartridge");
+		return;
+	}
+	if (address >= NAOMI_COMM2_CTRL_addr && address <= NAOMI_COMM2_STATUS1_addr
+			&& settings.platform.isNaomi())
+		m3comm.WriteMem(address, data, size);
+	else
+		CurrentCartridge->WriteMem(address, data, size);
+}
+
+static int naomiDmaSched(int tag, int sch_cycl, int jitter, void *arg)
+{
+	u32 start = SB_GDSTARD;
+	u32 len = std::min<int>(((SB_GDLEN + 31) & ~31) - SB_GDLEND, 1024);
+	SB_GDLEND += len;
+	while (len > 0)
+	{
+		u32 block_len = len;
+		void* ptr = CurrentCartridge->GetDmaPtr(block_len);
+		if (block_len == 0)
+		{
+			INFO_LOG(NAOMI, "Aborted DMA transfer. Read past end of cart?");
+			for (u32 i = 0; i < len; i += 8, start += 8)
+				addrspace::write64(start, 0);
+			break;
+		}
+		WriteMemBlock_nommu_ptr(start, (u32*)ptr, block_len);
+		CurrentCartridge->AdvancePtr(block_len);
+		len -= block_len;
+		start += block_len;
+	}
+	SB_GDSTARD = start;
+	if (SB_GDLEN <= SB_GDLEND)
+	{
+		SB_GDST = 0;
+		asic_RaiseInterrupt(holly_GDROM_DMA);
+		return 0;
+	}
+	else {
+		return std::min<int>(SB_GDLEN - SB_GDLEND, 1024) * dmaXferDelay;
+	}
+}
+
+//Dma Start
+static void Naomi_DmaStart(u32 addr, u32 data)
+{
+	if ((data & 1) == 0 || SB_GDST == 1)
+		return;
+	if (SB_GDEN == 0)
+	{
+		INFO_LOG(NAOMI, "Invalid NAOMI-DMA start, SB_GDEN=0. Ignoring it.");
+		return;
+	}
+	
+	if (multiboard != nullptr && multiboard->dmaStart())
+	{
+	}
+	else if (!m3comm.DmaStart(addr, data) && CurrentCartridge != nullptr)
+	{
+		DEBUG_LOG(NAOMI, "NAOMI-DMA start addr %08X len %x", SB_GDSTAR, SB_GDLEN);
+		verify(1 == SB_GDDIR);
+		SB_GDST = 1;
+		SB_GDSTARD = SB_GDSTAR & 0x1FFFFFE0;
+		SB_GDLEND = 0;
+		// Max G1 bus rate: 50 MHz x 16 bits
+		// SH4_access990312_e.xls: 14.4 MB/s from GD-ROM to system RAM
+		// Here: 20 MB/s
+		sh4_sched_request(dmaSchedId, std::min<int>(SB_GDLEN, 1024) * dmaXferDelay);
+		return;
+	}
+	else
+	{
+		SB_GDSTARD = SB_GDSTAR + SB_GDLEN;
+		SB_GDLEND = SB_GDLEN;
+	}
+	asic_RaiseInterrupt(holly_GDROM_DMA);
+}
+
+void Naomi_setDmaDelay()
+{
+	if (settings.platform.isAtomiswave() || settings.content.gameId == "FORCE FIVE"
+			|| settings.content.gameId == "KENJU")
+		// 7 MB/s for Atomiwave games and conversions
+		dmaXferDelay = 27;
+	else
+		dmaXferDelay = 10;
+}
+
+static void Naomi_DmaEnable(u32 addr, u32 data)
+{
+	SB_GDEN = data & 1;
+	if (SB_GDEN == 0 && SB_GDST == 1)
+	{
+		INFO_LOG(NAOMI, "NAOMI-DMA aborted");
+		SB_GDST = 0;
+		sh4_sched_request(dmaSchedId, -1);
+	}
+}
+
+void naomi_reg_Init()
+{
+	static const u8 romSerialData[0x84] = {
+		0x19, 0x00, 0xaa, 0x55,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x69, 0x79, 0x68, 0x6b, 0x74, 0x6d, 0x68, 0x6d,
+		0xa1, 0x09, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
+		' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',  ' ', ' ', ' ', ' ',
+		'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'
+	};
+	romSerialId.setData(romSerialData);
+	mainSerialId.setData(romSerialData);
+	if (dmaSchedId == -1)
+		dmaSchedId = sh4_sched_register(0, naomiDmaSched);
+}
+
+// Sets the full content of the rom board serial eeprom (132 bytes)
+// including response to reset and read/write passwords.
+void setGameSerialId(const u8 *data)
+{
+	romSerialId.setData(data);
+}
+
+// Return the protected data from the rom board serial eeprom (112 bytes)
+// excluding response to reset and passwords.
+const u8 *getGameSerialId()
+{
+	return romSerialId.getProtectedData();
+}
+
+void naomi_reg_Term()
+{
+	if (multiboard != nullptr)
+		delete multiboard;
+	multiboard = nullptr;
+	m3comm.closeNetwork();
+	networkOutput.term();
+	if (dmaSchedId != -1)
+		sh4_sched_unregister(dmaSchedId);
+	dmaSchedId = -1;
+	midiffb::term();
+}
+
+void naomi_reg_Reset(bool hard)
+{
+	hollyRegs.setWriteHandler<SB_GDST_addr>(Naomi_DmaStart);
+	hollyRegs.setWriteHandler<SB_GDEN_addr>(Naomi_DmaEnable);
+	SB_GDST = 0;
+	SB_GDEN = 0;
+	sh4_sched_request(dmaSchedId, -1);
+
+	atomiswave::reset();
+
+	m3comm.closeNetwork();
+	if (hard)
+	{
+		naomi_cart_Close();
+		if (multiboard != nullptr)
+		{
+			delete multiboard;
+			multiboard = nullptr;
+		}
+		if (settings.naomi.multiboard)
+			multiboard = new Multiboard();
+		networkOutput.reset();
+		mainSerialId.reset();
+		romSerialId.reset();
+	}
+	else if (multiboard != nullptr)
+		multiboard->reset();
+	midiffb::reset();
+}
+
+void naomi_Serialize(Serializer& ser)
+{
+	mainSerialId.serialize(ser);
+	romSerialId.serialize(ser);
+	atomiswave::serialize(ser);
+	// TODO serialize m3comm?
+	midiffb::serialize(ser);
+	sh4_sched_serialize(ser, dmaSchedId);
+}
+void naomi_Deserialize(Deserializer& deser)
+{
+	if (deser.version() < Deserializer::V40)
+	{
+		deser.skip<u32>();	// GSerialBuffer
+		deser.skip<u32>();	// BSerialBuffer
+		deser.skip<int>();	// GBufPos
+		deser.skip<int>();	// BBufPos
+		deser.skip<int>();	// GState
+		deser.skip<int>();	// BState
+		deser.skip<int>();	// GOldClk
+		deser.skip<int>();	// BOldClk
+		deser.skip<int>();	// BControl
+		deser.skip<int>();	// BCmd
+		deser.skip<int>();	// BLastCmd
+		deser.skip<int>();	// GControl
+		deser.skip<int>();	// GCmd
+		deser.skip<int>();	// GLastCmd
+		deser.skip<int>();	// SerStep
+		deser.skip<int>();	// SerStep2
+		deser.skip(69);		// BSerial
+		deser.skip(69);		// GSerial
+	}
+	else
+	{
+		mainSerialId.deserialize(deser);
+		romSerialId.deserialize(deser);
+	}
+	if (deser.version() < Deserializer::V36)
+	{
+		deser.skip<u32>(); // reg_dimm_command;
+		deser.skip<u32>(); // reg_dimm_offsetl;
+		deser.skip<u32>(); // reg_dimm_parameterl;
+		deser.skip<u32>(); // reg_dimm_parameterh;
+		deser.skip<u32>(); // reg_dimm_status;
+	}
+	atomiswave::deserialize(deser);
+	midiffb::deserialize(deser);
+	if (deser.version() >= Deserializer::V45)
+		sh4_sched_deserialize(deser, dmaSchedId);
+}
+
+struct DriveSimPipe : public SerialPort::Pipe
+{
+	void write(u8 data) override
+	{
+		if (buffer.empty() && data != 2)
+			return;
+		if (buffer.size() == 7)
+		{
+			u8 checksum = 0;
+			for (u8 b : buffer)
+				checksum += b;
+			if (checksum == data)
+			{
+				int newTacho = (buffer[2] - 1) * 100;
+				if (newTacho != tacho)
+				{
+					tacho = newTacho;
+					networkOutput.output("tachometer", tacho);
+				}
+				int newSpeed = buffer[3] - 1;
+				if (newSpeed != speed)
+				{
+					speed = newSpeed;
+					networkOutput.output("speedometer", speed);
+				}
+				if (!config::NetworkOutput)
+				{
+					std::string message = strprintf(i18n::T("Speed: %3d"), speed);
+					os_notify(message.c_str(), 1000);
+				}
+			}
+			buffer.clear();
+		}
+		else
+		{
+			buffer.push_back(data);
+		}
+	}
+
+	void reset()
+	{
+		buffer.clear();
+		tacho = -1;
+		speed = -1;
+	}
+private:
+	std::vector<u8> buffer;
+	int tacho = -1;
+	int speed = -1;
+};
+
+void initDriveSimSerialPipe()
+{
+	static DriveSimPipe pipe;
+
+	pipe.reset();
+	SCIFSerialPort::Instance().setPipe(&pipe);
+}
+
+G2PrinterConnection g2PrinterConnection;
+
+u32 G2PrinterConnection::read(u32 addr, u32 size)
+{
+	if (addr == STATUS_REG_ADDR)
+	{
+		u32 ret = printerStat;
+		printerStat |= 1;
+		DEBUG_LOG(NAOMI, "Printer status == %x", ret);
+		return ret;
+	}
+	else
+	{
+		INFO_LOG(NAOMI, "Unhandled G2 Ext read<%d> at %x", size, addr);
+		return 0;
+	}
+}
+
+void G2PrinterConnection::write(u32 addr, u32 size, u32 data)
+{
+	switch (addr)
+	{
+	case DATA_REG_ADDR:
+		for (u32 i = 0; i < size; i++)
+			printer::print((char)(data >> (i * 8)));
+		break;
+
+	case STATUS_REG_ADDR:
+		DEBUG_LOG(NAOMI, "Printer status = %x", data);
+		printerStat &= ~1;
+		break;
+
+	default:
+		INFO_LOG(NAOMI, "Unhandled G2 Ext write<%d> at %x: %x", size, addr, data);
+		break;
+	}
+}
+
diff --git a/core/hw/pvr/Renderer_if.cpp b/core/hw/pvr/Renderer_if.cpp
index 4fbb9a5..be30d56 100644
--- a/core/hw/pvr/Renderer_if.cpp
+++ b/core/hw/pvr/Renderer_if.cpp
@@ -14,6 +14,10 @@
 #include <mutex>
 #include <deque>
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
+
 #ifdef LIBRETRO
 void retro_rend_present();
 void retro_resize_renderer(int w, int h, float aspectRatio);
@@ -242,7 +246,18 @@ private:
 	{
 		FC_PROFILE_SCOPE;
 
+#ifdef __EMSCRIPTEN__
+		static int present_count = 0;
+		present_count++;
+		bool presResult = renderer->Present();
+		if (present_count <= 5) {
+			EM_ASM({ console.log('[rend] present #' + $0 + ': Present()=' + $1 + ' threaded=' + $2); },
+				present_count, presResult ? 1 : 0, (int)config::ThreadedRendering);
+		}
+		if (presResult)
+#else
 		if (renderer->Present())
+#endif
 		{
 			presented = true;
 			if (!config::ThreadedRendering && !ggpo::active())
@@ -457,6 +472,21 @@ int rend_end_render(int tag, int cycles, int jitter, void *arg)
 
 void rend_vblank()
 {
+#ifdef __EMSCRIPTEN__
+	static int vblank_count = 0;
+	static int last_fb_enable = -1;
+	static int last_fb_dirty = -1;
+	vblank_count++;
+	int cur_fb_enable = (int)FB_R_CTRL.fb_enable;
+	int cur_fb_dirty = (int)fb_dirty;
+	// Log on change or every 30 vblanks
+	if (cur_fb_enable != last_fb_enable || cur_fb_dirty != last_fb_dirty || (vblank_count % 30) == 0) {
+		EM_ASM({ console.log('[rend] vblank #' + $0 + ': fb_dirty=' + $1 + ' fb_enable=' + $2 + ' render_called=' + $3 + ' rend_enabled=' + $4); },
+			vblank_count, cur_fb_dirty, cur_fb_enable, (int)render_called, (int)rend_is_enabled());
+		last_fb_enable = cur_fb_enable;
+		last_fb_dirty = cur_fb_dirty;
+	}
+#endif
 	if (config::EmulateFramebuffer
 			|| (!render_called && fb_dirty && FB_R_CTRL.fb_enable))
 	{
diff --git a/core/hw/pvr/pvr_regs.cpp b/core/hw/pvr/pvr_regs.cpp
index 0538b3c..7379db7 100644
--- a/core/hw/pvr/pvr_regs.cpp
+++ b/core/hw/pvr/pvr_regs.cpp
@@ -1,254 +1,284 @@
-#include "pvr_regs.h"
-#include "pvr_mem.h"
-#include "Renderer_if.h"
-#include "ta.h"
-#include "spg.h"
-#include <map>
-
-bool pal_needs_update=true;
-
-u8 pvr_regs[pvr_RegSize];
-
-#define PVR_REG_NAME(r) { r##_addr, #r },
-const std::map<u32, const char *> pvr_reg_names = {
-		PVR_REG_NAME(ID)
-		PVR_REG_NAME(REVISION)
-		PVR_REG_NAME(SOFTRESET)
-		PVR_REG_NAME(STARTRENDER)
-		PVR_REG_NAME(TEST_SELECT)
-		PVR_REG_NAME(PARAM_BASE)
-		PVR_REG_NAME(REGION_BASE)
-		PVR_REG_NAME(SPAN_SORT_CFG)
-		PVR_REG_NAME(VO_BORDER_COL)
-		PVR_REG_NAME(FB_R_CTRL)
-		PVR_REG_NAME(FB_W_CTRL)
-		PVR_REG_NAME(FB_W_LINESTRIDE)
-		PVR_REG_NAME(FB_R_SOF1)
-		PVR_REG_NAME(FB_R_SOF2)
-		PVR_REG_NAME(FB_R_SIZE)
-		PVR_REG_NAME(FB_W_SOF1)
-		PVR_REG_NAME(FB_W_SOF2)
-		PVR_REG_NAME(FB_X_CLIP)
-		PVR_REG_NAME(FB_Y_CLIP)
-		PVR_REG_NAME(FPU_SHAD_SCALE)
-		PVR_REG_NAME(FPU_CULL_VAL)
-		PVR_REG_NAME(FPU_PARAM_CFG)
-		PVR_REG_NAME(HALF_OFFSET)
-		PVR_REG_NAME(FPU_PERP_VAL)
-		PVR_REG_NAME(ISP_BACKGND_D)
-		PVR_REG_NAME(ISP_BACKGND_T)
-		PVR_REG_NAME(ISP_FEED_CFG)
-		PVR_REG_NAME(SDRAM_REFRESH)
-		PVR_REG_NAME(SDRAM_ARB_CFG)
-		PVR_REG_NAME(SDRAM_CFG)
-		PVR_REG_NAME(FOG_COL_RAM)
-		PVR_REG_NAME(FOG_COL_VERT)
-		PVR_REG_NAME(FOG_DENSITY)
-		PVR_REG_NAME(FOG_CLAMP_MAX)
-		PVR_REG_NAME(FOG_CLAMP_MIN)
-		PVR_REG_NAME(SPG_TRIGGER_POS)
-		PVR_REG_NAME(SPG_HBLANK_INT)
-		PVR_REG_NAME(SPG_VBLANK_INT)
-		PVR_REG_NAME(SPG_CONTROL)
-		PVR_REG_NAME(SPG_HBLANK)
-		PVR_REG_NAME(SPG_LOAD)
-		PVR_REG_NAME(SPG_VBLANK)
-		PVR_REG_NAME(SPG_WIDTH)
-		PVR_REG_NAME(TEXT_CONTROL)
-		PVR_REG_NAME(VO_CONTROL)
-		PVR_REG_NAME(VO_STARTX)
-		PVR_REG_NAME(VO_STARTY)
-		PVR_REG_NAME(SCALER_CTL)
-		PVR_REG_NAME(PAL_RAM_CTRL)
-		PVR_REG_NAME(SPG_STATUS)
-		PVR_REG_NAME(FB_BURSTCTRL)
-		PVR_REG_NAME(FB_C_SOF)
-		PVR_REG_NAME(Y_COEFF)
-		PVR_REG_NAME(PT_ALPHA_REF)
-		PVR_REG_NAME(TA_OL_BASE)
-		PVR_REG_NAME(TA_ISP_BASE)
-		PVR_REG_NAME(TA_OL_LIMIT)
-		PVR_REG_NAME(TA_ISP_LIMIT)
-		PVR_REG_NAME(TA_NEXT_OPB)
-		PVR_REG_NAME(TA_ITP_CURRENT)
-		PVR_REG_NAME(TA_GLOB_TILE_CLIP)
-		PVR_REG_NAME(TA_ALLOC_CTRL)
-		PVR_REG_NAME(TA_LIST_INIT)
-		PVR_REG_NAME(TA_YUV_TEX_BASE)
-		PVR_REG_NAME(TA_YUV_TEX_CTRL)
-		PVR_REG_NAME(TA_YUV_TEX_CNT)
-		PVR_REG_NAME(TA_LIST_CONT)
-		PVR_REG_NAME(TA_NEXT_OPB_INIT)
-		PVR_REG_NAME(SIGNATURE1)
-		PVR_REG_NAME(SIGNATURE2)
-};
-#undef PVR_REG_NAME
-
-static const char *regName(u32 paddr)
-{
-	u32 addr = paddr & pvr_RegMask;
-	static char regName[32];
-	auto it = pvr_reg_names.find(addr);
-	if (it == pvr_reg_names.end())
-	{
-		if (addr >= FOG_TABLE_START_addr && addr <= FOG_TABLE_END_addr)
-			snprintf(regName, sizeof(regName), "FOG_TABLE[%x]", addr - FOG_TABLE_START_addr);
-		else if (addr >= TA_OL_POINTERS_START_addr && addr <= TA_OL_POINTERS_END_addr)
-			snprintf(regName, sizeof(regName), "TA_OL_POINTERS[%x]", addr - TA_OL_POINTERS_START_addr);
-		else if (addr >= PALETTE_RAM_START_addr && addr <= PALETTE_RAM_END_addr)
-			snprintf(regName, sizeof(regName), "PALETTE[%x]", addr - PALETTE_RAM_START_addr);
-		else
-			snprintf(regName, sizeof(regName), "?%08x", paddr);
-		return regName;
-	}
-	else
-		return it->second;
-}
-
-u32 pvr_ReadReg(u32 addr)
-{
-	if ((addr & pvr_RegMask) != SPG_STATUS_addr)
-		DEBUG_LOG(PVR, "read %s.%c == %x", regName(addr),
-				((addr >> 26) & 7) == 2 ? 'b' : (addr & 0x2000000) ? '1' : '0',
-						PvrReg(addr, u32));
-	return PvrReg(addr,u32);
-}
-
-void pvr_WriteReg(u32 paddr,u32 data)
-{
-	u32 addr = paddr & pvr_RegMask;
-	DEBUG_LOG(PVR, "write %s.%c = %x", regName(paddr),
-			((paddr >> 26) & 7) == 2 ? 'b' : (paddr & 0x2000000) ? '1' : '0',
-					data);
-
-	switch (addr)
-	{
-	case ID_addr:
-	case REVISION_addr:
-	case TA_YUV_TEX_CNT_addr:
-		return; // read only
-
-	case STARTRENDER_addr:
-		rend_start_render();
-		YUV_init();
-		return;
-
-	case TA_LIST_INIT_addr:
-		if (data >> 31)
-		{
-			ta_vtx_ListInit(false);
-			TA_NEXT_OPB = TA_NEXT_OPB_INIT;
-			TA_ITP_CURRENT = TA_ISP_BASE;
-		}
-		return;
-
-	case SOFTRESET_addr:
-		if (data & 1)
-			ta_vtx_SoftReset();
-		return;
-
-	case TA_LIST_CONT_addr:
-		//a write of anything works ?
-		ta_vtx_ListInit(true);
-		break;
-	
-	case SPG_CONTROL_addr:
-	case SPG_LOAD_addr:
-		if (PvrReg(addr, u32) != data)
-		{
-			PvrReg(addr, u32) = data;
-			CalculateSync();
-		}
-		return;
-
-	case FB_R_CTRL_addr:
-		{
-			bool vclk_div_changed = (PvrReg(addr, u32) ^ data) & (1 << 23);
-			PvrReg(addr, u32) = data;
-			if (vclk_div_changed)
-				CalculateSync();
-		}
-		return;
-
-	case FB_R_SIZE_addr:
-		if (PvrReg(addr, u32) != data)
-		{
-			PvrReg(addr, u32) = data;
-			fb_dirty = false;
-			check_framebuffer_write();
-		}
-		return;
-
-	case TA_YUV_TEX_BASE_addr:
-		PvrReg(addr, u32) = data & 0x00FFFFF8;
-		YUV_init();
-		return;
-
-	case TA_YUV_TEX_CTRL_addr:
-		PvrReg(addr, u32) = data;
-		YUV_init();
-		return;
-
-	case FB_R_SOF1_addr:
-	case FB_R_SOF2_addr:
-		data &= 0x00fffffc;
-		rend_swap_frame(data);
-		break;
-
-	case FB_W_SOF1_addr:
-		data &= 0x01fffffc;
-		rend_set_fb_write_addr(data);
-		break;
-
-	case FB_W_SOF2_addr:
-		data &= 0x01fffffc;
-		break;
-
-	case SPG_HBLANK_INT_addr:
-		data &= 0x03FF33FF;
-		if (data != SPG_HBLANK_INT.full) {
-			SPG_HBLANK_INT.full = data;
-			rescheduleSPG();
-		}
-		return;
-
-	case PAL_RAM_CTRL_addr:
-		pal_needs_update = pal_needs_update || ((data ^ PAL_RAM_CTRL) & 3) != 0;
-		break;
-
-	default:
-		if (addr >= PALETTE_RAM_START_addr && PvrReg(addr,u32) != data)
-			pal_needs_update = true;
-		else if (addr >= FOG_TABLE_START_addr && addr <= FOG_TABLE_END_addr && PvrReg(addr,u32) != data)
-			rend_updateFogTable();
-		break;
-	}
-	PvrReg(addr, u32) = data;
-}
-
-void Regs_Reset(bool hard)
-{
-	if (hard)
-		memset(&pvr_regs[0], 0, sizeof(pvr_regs));
-	ID_Reg              = 0x17FD11DB;
-	REVISION            = 0x00000011;
-	SOFTRESET           = 0x00000007;
-	SPG_HBLANK_INT.full = 0x031D0000;
-	SPG_VBLANK_INT.full = 0x00150104;
-	FPU_PARAM_CFG       = 0x0007DF77;
-	HALF_OFFSET         = 0x00000007;
-	ISP_FEED_CFG        = 0x00402000;
-	SDRAM_REFRESH       = 0x00000020;
-	SDRAM_ARB_CFG       = 0x0000001F;
-	SDRAM_CFG           = 0x15F28997;
-	SPG_HBLANK.full     = 0x007E0345;
-	SPG_LOAD.full       = 0x01060359;
-	SPG_VBLANK.full     = 0x01500104;
-	SPG_WIDTH.full      = 0x07F1933F;
-	VO_CONTROL.full     = 0x00000108;
-	VO_STARTX.full      = 0x0000009D;
-	VO_STARTY.full      = 0x00150015;
-	SCALER_CTL.full     = 0x00000400;
-	FB_BURSTCTRL        = 0x00090639;
-	PT_ALPHA_REF        = 0x000000FF;
-}
+#include "pvr_regs.h"
+#include "pvr_mem.h"
+#include "Renderer_if.h"
+#include "ta.h"
+#include "spg.h"
+#include <map>
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#include "hw/sh4/sh4_core.h"  // for Sh4cntx (sh4ctx->pc)
+extern u32 g_wasm_block_count;
+#endif
+
+bool pal_needs_update=true;
+
+u8 pvr_regs[pvr_RegSize];
+
+#define PVR_REG_NAME(r) { r##_addr, #r },
+const std::map<u32, const char *> pvr_reg_names = {
+		PVR_REG_NAME(ID)
+		PVR_REG_NAME(REVISION)
+		PVR_REG_NAME(SOFTRESET)
+		PVR_REG_NAME(STARTRENDER)
+		PVR_REG_NAME(TEST_SELECT)
+		PVR_REG_NAME(PARAM_BASE)
+		PVR_REG_NAME(REGION_BASE)
+		PVR_REG_NAME(SPAN_SORT_CFG)
+		PVR_REG_NAME(VO_BORDER_COL)
+		PVR_REG_NAME(FB_R_CTRL)
+		PVR_REG_NAME(FB_W_CTRL)
+		PVR_REG_NAME(FB_W_LINESTRIDE)
+		PVR_REG_NAME(FB_R_SOF1)
+		PVR_REG_NAME(FB_R_SOF2)
+		PVR_REG_NAME(FB_R_SIZE)
+		PVR_REG_NAME(FB_W_SOF1)
+		PVR_REG_NAME(FB_W_SOF2)
+		PVR_REG_NAME(FB_X_CLIP)
+		PVR_REG_NAME(FB_Y_CLIP)
+		PVR_REG_NAME(FPU_SHAD_SCALE)
+		PVR_REG_NAME(FPU_CULL_VAL)
+		PVR_REG_NAME(FPU_PARAM_CFG)
+		PVR_REG_NAME(HALF_OFFSET)
+		PVR_REG_NAME(FPU_PERP_VAL)
+		PVR_REG_NAME(ISP_BACKGND_D)
+		PVR_REG_NAME(ISP_BACKGND_T)
+		PVR_REG_NAME(ISP_FEED_CFG)
+		PVR_REG_NAME(SDRAM_REFRESH)
+		PVR_REG_NAME(SDRAM_ARB_CFG)
+		PVR_REG_NAME(SDRAM_CFG)
+		PVR_REG_NAME(FOG_COL_RAM)
+		PVR_REG_NAME(FOG_COL_VERT)
+		PVR_REG_NAME(FOG_DENSITY)
+		PVR_REG_NAME(FOG_CLAMP_MAX)
+		PVR_REG_NAME(FOG_CLAMP_MIN)
+		PVR_REG_NAME(SPG_TRIGGER_POS)
+		PVR_REG_NAME(SPG_HBLANK_INT)
+		PVR_REG_NAME(SPG_VBLANK_INT)
+		PVR_REG_NAME(SPG_CONTROL)
+		PVR_REG_NAME(SPG_HBLANK)
+		PVR_REG_NAME(SPG_LOAD)
+		PVR_REG_NAME(SPG_VBLANK)
+		PVR_REG_NAME(SPG_WIDTH)
+		PVR_REG_NAME(TEXT_CONTROL)
+		PVR_REG_NAME(VO_CONTROL)
+		PVR_REG_NAME(VO_STARTX)
+		PVR_REG_NAME(VO_STARTY)
+		PVR_REG_NAME(SCALER_CTL)
+		PVR_REG_NAME(PAL_RAM_CTRL)
+		PVR_REG_NAME(SPG_STATUS)
+		PVR_REG_NAME(FB_BURSTCTRL)
+		PVR_REG_NAME(FB_C_SOF)
+		PVR_REG_NAME(Y_COEFF)
+		PVR_REG_NAME(PT_ALPHA_REF)
+		PVR_REG_NAME(TA_OL_BASE)
+		PVR_REG_NAME(TA_ISP_BASE)
+		PVR_REG_NAME(TA_OL_LIMIT)
+		PVR_REG_NAME(TA_ISP_LIMIT)
+		PVR_REG_NAME(TA_NEXT_OPB)
+		PVR_REG_NAME(TA_ITP_CURRENT)
+		PVR_REG_NAME(TA_GLOB_TILE_CLIP)
+		PVR_REG_NAME(TA_ALLOC_CTRL)
+		PVR_REG_NAME(TA_LIST_INIT)
+		PVR_REG_NAME(TA_YUV_TEX_BASE)
+		PVR_REG_NAME(TA_YUV_TEX_CTRL)
+		PVR_REG_NAME(TA_YUV_TEX_CNT)
+		PVR_REG_NAME(TA_LIST_CONT)
+		PVR_REG_NAME(TA_NEXT_OPB_INIT)
+		PVR_REG_NAME(SIGNATURE1)
+		PVR_REG_NAME(SIGNATURE2)
+};
+#undef PVR_REG_NAME
+
+static const char *regName(u32 paddr)
+{
+	u32 addr = paddr & pvr_RegMask;
+	static char regName[32];
+	auto it = pvr_reg_names.find(addr);
+	if (it == pvr_reg_names.end())
+	{
+		if (addr >= FOG_TABLE_START_addr && addr <= FOG_TABLE_END_addr)
+			snprintf(regName, sizeof(regName), "FOG_TABLE[%x]", addr - FOG_TABLE_START_addr);
+		else if (addr >= TA_OL_POINTERS_START_addr && addr <= TA_OL_POINTERS_END_addr)
+			snprintf(regName, sizeof(regName), "TA_OL_POINTERS[%x]", addr - TA_OL_POINTERS_START_addr);
+		else if (addr >= PALETTE_RAM_START_addr && addr <= PALETTE_RAM_END_addr)
+			snprintf(regName, sizeof(regName), "PALETTE[%x]", addr - PALETTE_RAM_START_addr);
+		else
+			snprintf(regName, sizeof(regName), "?%08x", paddr);
+		return regName;
+	}
+	else
+		return it->second;
+}
+
+u32 pvr_ReadReg(u32 addr)
+{
+	if ((addr & pvr_RegMask) != SPG_STATUS_addr)
+		DEBUG_LOG(PVR, "read %s.%c == %x", regName(addr),
+				((addr >> 26) & 7) == 2 ? 'b' : (addr & 0x2000000) ? '1' : '0',
+						PvrReg(addr, u32));
+	return PvrReg(addr,u32);
+}
+
+void pvr_WriteReg(u32 paddr,u32 data)
+{
+	u32 addr = paddr & pvr_RegMask;
+	DEBUG_LOG(PVR, "write %s.%c = %x", regName(paddr),
+			((paddr >> 26) & 7) == 2 ? 'b' : (paddr & 0x2000000) ? '1' : '0',
+					data);
+
+	switch (addr)
+	{
+	case ID_addr:
+	case REVISION_addr:
+	case TA_YUV_TEX_CNT_addr:
+		return; // read only
+
+	case STARTRENDER_addr:
+#ifdef __EMSCRIPTEN__
+		{
+			static int startrender_count = 0;
+			startrender_count++;
+			EM_ASM({ console.log('[STARTRENDER] #' + $0 +
+				' blk=' + $1 +
+				' pc=0x' + ($2>>>0).toString(16)); },
+				startrender_count, g_wasm_block_count, p_sh4rcb->cntx.pc);
+		}
+#endif
+		rend_start_render();
+		YUV_init();
+		return;
+
+	case TA_LIST_INIT_addr:
+		if (data >> 31)
+		{
+			ta_vtx_ListInit(false);
+			TA_NEXT_OPB = TA_NEXT_OPB_INIT;
+			TA_ITP_CURRENT = TA_ISP_BASE;
+		}
+		return;
+
+	case SOFTRESET_addr:
+		if (data & 1)
+			ta_vtx_SoftReset();
+		return;
+
+	case TA_LIST_CONT_addr:
+		//a write of anything works ?
+		ta_vtx_ListInit(true);
+		break;
+	
+	case SPG_CONTROL_addr:
+	case SPG_LOAD_addr:
+		if (PvrReg(addr, u32) != data)
+		{
+			PvrReg(addr, u32) = data;
+			CalculateSync();
+		}
+		return;
+
+	case FB_R_CTRL_addr:
+		{
+#ifdef __EMSCRIPTEN__
+			static int fb_r_ctrl_write_count = 0;
+			fb_r_ctrl_write_count++;
+			u32 old_val = PvrReg(addr, u32);
+			u32 sh4_pc = p_sh4rcb->cntx.pc;
+			// Log ALL writes to FB_R_CTRL with block count and SH4 PC
+			EM_ASM({ console.log('[FB_R_CTRL-WR] #' + $0 +
+				' blk=' + $1 +
+				' pc=0x' + ($2>>>0).toString(16) +
+				' old=0x' + ($3>>>0).toString(16) +
+				' new=0x' + ($4>>>0).toString(16) +
+				' fb_enable: ' + ($3 & 1) + '->' + ($4 & 1)); },
+				fb_r_ctrl_write_count, g_wasm_block_count, sh4_pc,
+				old_val, data);
+#endif
+			bool vclk_div_changed = (PvrReg(addr, u32) ^ data) & (1 << 23);
+			PvrReg(addr, u32) = data;
+			if (vclk_div_changed)
+				CalculateSync();
+		}
+		return;
+
+	case FB_R_SIZE_addr:
+		if (PvrReg(addr, u32) != data)
+		{
+			PvrReg(addr, u32) = data;
+			fb_dirty = false;
+			check_framebuffer_write();
+		}
+		return;
+
+	case TA_YUV_TEX_BASE_addr:
+		PvrReg(addr, u32) = data & 0x00FFFFF8;
+		YUV_init();
+		return;
+
+	case TA_YUV_TEX_CTRL_addr:
+		PvrReg(addr, u32) = data;
+		YUV_init();
+		return;
+
+	case FB_R_SOF1_addr:
+	case FB_R_SOF2_addr:
+		data &= 0x00fffffc;
+		rend_swap_frame(data);
+		break;
+
+	case FB_W_SOF1_addr:
+		data &= 0x01fffffc;
+		rend_set_fb_write_addr(data);
+		break;
+
+	case FB_W_SOF2_addr:
+		data &= 0x01fffffc;
+		break;
+
+	case SPG_HBLANK_INT_addr:
+		data &= 0x03FF33FF;
+		if (data != SPG_HBLANK_INT.full) {
+			SPG_HBLANK_INT.full = data;
+			rescheduleSPG();
+		}
+		return;
+
+	case PAL_RAM_CTRL_addr:
+		pal_needs_update = pal_needs_update || ((data ^ PAL_RAM_CTRL) & 3) != 0;
+		break;
+
+	default:
+		if (addr >= PALETTE_RAM_START_addr && PvrReg(addr,u32) != data)
+			pal_needs_update = true;
+		else if (addr >= FOG_TABLE_START_addr && addr <= FOG_TABLE_END_addr && PvrReg(addr,u32) != data)
+			rend_updateFogTable();
+		break;
+	}
+	PvrReg(addr, u32) = data;
+}
+
+void Regs_Reset(bool hard)
+{
+	if (hard)
+		memset(&pvr_regs[0], 0, sizeof(pvr_regs));
+	ID_Reg              = 0x17FD11DB;
+	REVISION            = 0x00000011;
+	SOFTRESET           = 0x00000007;
+	SPG_HBLANK_INT.full = 0x031D0000;
+	SPG_VBLANK_INT.full = 0x00150104;
+	FPU_PARAM_CFG       = 0x0007DF77;
+	HALF_OFFSET         = 0x00000007;
+	ISP_FEED_CFG        = 0x00402000;
+	SDRAM_REFRESH       = 0x00000020;
+	SDRAM_ARB_CFG       = 0x0000001F;
+	SDRAM_CFG           = 0x15F28997;
+	SPG_HBLANK.full     = 0x007E0345;
+	SPG_LOAD.full       = 0x01060359;
+	SPG_VBLANK.full     = 0x01500104;
+	SPG_WIDTH.full      = 0x07F1933F;
+	VO_CONTROL.full     = 0x00000108;
+	VO_STARTX.full      = 0x0000009D;
+	VO_STARTY.full      = 0x00150015;
+	SCALER_CTL.full     = 0x00000400;
+	FB_BURSTCTRL        = 0x00090639;
+	PT_ALPHA_REF        = 0x000000FF;
+}
diff --git a/core/hw/sh4/dyna/driver.cpp b/core/hw/sh4/dyna/driver.cpp
index 4e1fbf3..4f61459 100644
--- a/core/hw/sh4/dyna/driver.cpp
+++ b/core/hw/sh4/dyna/driver.cpp
@@ -1,6 +1,10 @@
 #include "types.h"
 #include <unordered_set>
 
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
+
 #include "hw/sh4/sh4_interpreter.h"
 #include "hw/sh4/sh4_core.h"
 #include "hw/sh4/sh4_interrupts.h"
@@ -15,6 +19,10 @@
 
 #if FEAT_SHREC != DYNAREC_NONE
 
+#if defined(__EMSCRIPTEN__) && HOST_CPU == CPU_GENERIC
+extern "C" void wasm_dynarec_init();
+#endif
+
 constexpr u32 CODE_SIZE = 10_MB;
 constexpr u32 TEMP_CODE_SIZE = 1_MB;
 constexpr u32 FULL_SIZE = CODE_SIZE + TEMP_CODE_SIZE;
@@ -342,26 +350,54 @@ void Sh4Recompiler::Reset(bool hard)
 void Sh4Recompiler::Init()
 {
 	INFO_LOG(DYNAREC, "Sh4Recompiler::Init");
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 1: super::Init()'); });
+#endif
 	super::Init();
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 2: bm_Init()'); });
+#endif
 	bm_Init();
-	
+
 	if (addrspace::virtmemEnabled())
 		verify(&mem_b[0] == ((u8*)getContext()->sq_buffer + sizeof(Sh4Context) + 0x0C000000));
 
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 3: prepare_jit_block()'); });
+#endif
 	// Call the platform-specific magic to make the pages RWX
 	CodeCache = nullptr;
 #ifdef FEAT_NO_RWX_PAGES
 	bool rc = virtmem::prepare_jit_block(SH4_TCB, FULL_SIZE, (void**)&CodeCache, &cc_rx_offset);
 #else
 	bool rc = virtmem::prepare_jit_block(SH4_TCB, FULL_SIZE, (void**)&CodeCache);
+#endif
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 3 result: rc=' + $0 + ' CodeCache=' + $1); }, (int)rc, (int)(uintptr_t)CodeCache);
 #endif
 	verify(rc);
 	// Ensure the pointer returned is non-null
 	verify(CodeCache != nullptr);
 
 	TempCodeCache = CodeCache + CODE_SIZE;
+#if defined(__EMSCRIPTEN__) && HOST_CPU == CPU_GENERIC
+	// Ensure WASM dynarec is initialized — the static constructor may not have
+	// run if the linker stripped the translation unit from the archive.
+	wasm_dynarec_init();
+#endif
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 4: sh4Dynarec->init(), sh4Dynarec=' + $0 + ' ctx=' + $1); },
+		(int)(uintptr_t)sh4Dynarec, (int)(uintptr_t)getContext());
+#endif
+	verify(sh4Dynarec != nullptr);
 	sh4Dynarec->init(*getContext(), codeBuffer);
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — step 5: bm_ResetCache()'); });
+#endif
 	bm_ResetCache();
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.log('[rec_wasm] Sh4Recompiler::Init() — COMPLETE'); });
+#endif
 }
 
 void Sh4Recompiler::Term()
diff --git a/core/hw/sh4/dyna/shil_canonical.h b/core/hw/sh4/dyna/shil_canonical.h
index a1be200..3727ab8 100644
--- a/core/hw/sh4/dyna/shil_canonical.h
+++ b/core/hw/sh4/dyna/shil_canonical.h
@@ -747,6 +747,22 @@ u32,f1,(f32 f1),
 	}
 	return res;
 )
+#else
+// CPU_GENERIC (Emscripten/WASM) — same behavior as ARM (NaN → 0x80000000)
+shil_canonical
+(
+u32,f1,(f32 f1),
+	s32 res;
+	if (f1 > 2147483520.0f) {
+		res = 0x7fffffff;
+	}
+	else {
+		res = (s32)f1;
+		if (std::isnan(f1))
+			res = 0x80000000;
+	}
+	return res;
+)
 #endif
 
 shil_compile
diff --git a/core/hw/sh4/dyna/ssa.cpp b/core/hw/sh4/dyna/ssa.cpp
index 85c1fdf..a62439b 100644
--- a/core/hw/sh4/dyna/ssa.cpp
+++ b/core/hw/sh4/dyna/ssa.cpp
@@ -489,6 +489,11 @@ void SSAOptimizer::ConstPropPass()
 				// and if those pages are read-only, then we can directly read the memory at compile time
 				// and propagate the read value as a constant.
 				if (op.op == shop_readm  && block->read_only
+#ifdef __EMSCRIPTEN__
+						&& false  // WASM: mprotect is a no-op, so read-only pages
+						          // aren't actually protected. Compile-time reads
+						          // become stale when the page is written to.
+#endif
 						&& (op.rs1._imm >> 12) >= (block->vaddr >> 12)
 						&& (op.rs1._imm >> 12) <= ((block->vaddr + block->sh4_code_size - 1) >> 12)
 						&& op.size <= 4)
diff --git a/core/hw/sh4/sh4_core_regs.cpp b/core/hw/sh4/sh4_core_regs.cpp
index 7542f13..bfaec7d 100644
--- a/core/hw/sh4/sh4_core_regs.cpp
+++ b/core/hw/sh4/sh4_core_regs.cpp
@@ -120,6 +120,10 @@ static void setHostRoundingMode(u32 roundingMode, u32 denorm2zero)
                 : "r"(off_mask), "r"(on_mask)
 				: "x10"
             );
+    #elif defined(__EMSCRIPTEN__) || defined(__wasm__) || HOST_CPU == CPU_GENERIC
+		// WASM/generic: no hardware FPU control — rounding mode is not configurable
+		(void)roundingMode;
+		(void)denorm2zero;
     #else
 	#error "SetFloatStatusReg: Unsupported platform"
     #endif
diff --git a/core/linux/context.cpp b/core/linux/context.cpp
index 461ff26..a8ba32c 100644
--- a/core/linux/context.cpp
+++ b/core/linux/context.cpp
@@ -130,6 +130,10 @@ static void context_segfault(host_context_t* hostctx, void* segfault_ctx)
     #else
         #error "Unsupported OS"
 	#endif
+#elif HOST_CPU == CPU_GENERIC
+	// No segfault context handling for generic/WASM platform (interpreter only)
+	(void)hostctx;
+	(void)segfault_ctx;
 #else
 	#error Unsupported HOST_CPU
 #endif
diff --git a/core/linux/posix_vmem.cpp b/core/linux/posix_vmem.cpp
index 4610515..f52ac64 100644
--- a/core/linux/posix_vmem.cpp
+++ b/core/linux/posix_vmem.cpp
@@ -4,7 +4,7 @@
 // Android and OSX since they are slightly different in some areas.
 #include "types.h"
 
-#ifndef __SWITCH__
+#if !defined(__SWITCH__) && !defined(__EMSCRIPTEN__)
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -326,7 +326,50 @@ void release_jit_block(void *code_area1, void *code_area2, size_t size)
 
 } // namespace virtmem
 
-#endif // !__SWITCH__
+#endif // !__SWITCH__ && !__EMSCRIPTEN__
+
+#ifdef __EMSCRIPTEN__
+// Emscripten: no mmap/shm_open/mprotect support.
+// All virtmem functions are no-ops. addrspace::initMappings() will use
+// the malloc-based fallback path when virtmem::init() returns false.
+#include "hw/mem/addrspace.h"
+#include "hw/sh4/sh4_if.h"
+#include "oslib/virtmem.h"
+
+namespace virtmem
+{
+
+bool region_lock(void *start, size_t len) { return true; }
+bool region_unlock(void *start, size_t len) { return true; }
+bool region_set_exec(void *start, size_t len) { return true; }
+bool init(void **vmem_base_addr, void **sh4rcb_addr, size_t ramSize) { return false; }
+void destroy() {}
+void reset_mem(void *ptr, unsigned size_bytes) { memset(ptr, 0, size_bytes); }
+void ondemand_page(void *address, unsigned size_bytes) {}
+void create_mappings(const Mapping *vmem_maps, unsigned nummaps) {}
+bool prepare_jit_block(void *code_area, size_t size, void **code_area_rwx) {
+	// WASM JIT: no native code execution, but we need a valid buffer for the block manager
+	// Allocate a dummy buffer — rec_wasm doesn't write native code into it, but driver.cpp expects non-null
+	static u8* wasmJitBuffer = nullptr;
+	if (!wasmJitBuffer)
+		wasmJitBuffer = (u8*)malloc(size);
+	if (!wasmJitBuffer)
+		return false;
+	memset(wasmJitBuffer, 0, size);
+	*code_area_rwx = wasmJitBuffer;
+	return true;
+}
+bool prepare_jit_block(void *code_area, size_t size, void **code_area_rw, ptrdiff_t *rx_offset) {
+	bool rc = prepare_jit_block(code_area, size, code_area_rw);
+	if (rc && rx_offset)
+		*rx_offset = 0;
+	return rc;
+}
+void release_jit_block(void *code_area, size_t size) { /* buffer is static, leaked intentionally */ }
+void release_jit_block(void *code_area1, void *code_area2, size_t size) {}
+
+} // namespace virtmem
+#endif // __EMSCRIPTEN__
 
 namespace virtmem
 {
diff --git a/core/oslib/virtmem.h b/core/oslib/virtmem.h
index 143d093..5b72309 100644
--- a/core/oslib/virtmem.h
+++ b/core/oslib/virtmem.h
@@ -1,7 +1,10 @@
 #pragma once
 #include "types.h"
 
-#if defined(_WIN32) || defined(TARGET_IPHONE) || defined(TARGET_ARM_MAC)
+#if defined(__EMSCRIPTEN__)
+// Emscripten: no native code execution. Use a pointer (allocated via malloc in prepare_jit_block).
+#define DECLARE_CODE_CACHE(Name, Size) static u8 *Name;
+#elif defined(_WIN32) || defined(TARGET_IPHONE) || defined(TARGET_ARM_MAC)
 #define DECLARE_CODE_CACHE(Name, Size) static u8 *Name;
 #elif defined(__ANDROID__)
 #define DECLARE_CODE_CACHE(Name, Size) alignas(4096) static u8 Name[Size];
diff --git a/core/ui/gui.cpp b/core/ui/gui.cpp
index 0f29057..4f87441 100644
--- a/core/ui/gui.cpp
+++ b/core/ui/gui.cpp
@@ -17,6 +17,9 @@
     along with Flycast.  If not, see <https://www.gnu.org/licenses/>.
  */
 #include "gui.h"
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 #include "rend/osd.h"
 #include "cfg/cfg.h"
 #include "imgui.h"
@@ -1716,6 +1719,11 @@ void fatal_error(const char* text, ...)
     vsnprintf(temp, sizeof(temp), text, args);
     va_end(args);
     ERROR_LOG(COMMON, "%s", temp);
+#ifdef __EMSCRIPTEN__
+    // Make fatal errors visible in browser console (ERROR_LOG and os_notify
+    // don't reach console.log on Emscripten)
+    EM_ASM({ console.error('[FATAL] ' + UTF8ToString($0)); }, temp);
+#endif
 
     os_notify("Fatal Error", 20000, temp);
 }
diff --git a/shell/cmake/DetectArchitecture.cmake b/shell/cmake/DetectArchitecture.cmake
index 9a4b855..031fd86 100644
--- a/shell/cmake/DetectArchitecture.cmake
+++ b/shell/cmake/DetectArchitecture.cmake
@@ -21,6 +21,9 @@ function(detect_architecture symbol arch)
     endif()
 endfunction()
 
+detect_architecture("__EMSCRIPTEN__" wasm32)
+detect_architecture("__wasm__" wasm32)
+
 detect_architecture("__ARM64__" arm64)
 detect_architecture("__aarch64__" arm64)
 detect_architecture("_M_ARM64" arm64)
diff --git a/shell/libretro/libretro.cpp b/shell/libretro/libretro.cpp
index 9dcc6b3..9b4e7c2 100644
--- a/shell/libretro/libretro.cpp
+++ b/shell/libretro/libretro.cpp
@@ -18,6 +18,9 @@
 #include <cstdarg>
 #include <math.h>
 #include "types.h"
+#ifdef __EMSCRIPTEN__
+#include <emscripten.h>
+#endif
 #ifndef _WIN32
 #include <sys/time.h>
 #endif
@@ -1198,6 +1201,67 @@ static void update_variables(bool first_startup)
 
 void retro_run()
 {
+#ifdef __EMSCRIPTEN__
+	// Frame pacing: cap at ~60fps regardless of display refresh rate.
+	// On 120Hz+ monitors, rAF fires faster than 60Hz, causing 2x+ game speed.
+	{
+		static double last_frame_ms = 0;
+		static int real_frames = 0;
+		static int skipped_frames = 0;
+		static double hud_last_update = 0;
+
+		double now = emscripten_get_now();
+
+		if (last_frame_ms > 0 && (now - last_frame_ms) < 15.0) {
+			skipped_frames++;
+			video_cb(0, framebufferWidth, framebufferHeight, 0);
+			// Update HUD even on skipped frames so skip count stays current
+			if (now - hud_last_update >= 1000.0) {
+				double speed_pct = (real_frames / 60.0) * 100.0;
+				EM_ASM({
+					var el = document.getElementById('fc-hud');
+					if (!el) {
+						el = document.createElement('div');
+						el.id = 'fc-hud';
+						el.style.cssText = 'position:fixed;top:8px;left:8px;z-index:99999;'
+							+ 'background:rgba(0,0,0,0.7);color:#fff;font:12px monospace;'
+							+ 'padding:4px 8px;pointer-events:none;border-radius:3px;';
+						document.body.appendChild(el);
+					}
+					el.textContent = 'FPS:' + $0 + ' Skip:' + $1 + ' Speed:' + $2.toFixed(0) + '%';
+				}, real_frames, skipped_frames, speed_pct);
+				real_frames = 0;
+				skipped_frames = 0;
+				hud_last_update = now;
+			}
+			return;
+		}
+		last_frame_ms = now;
+		real_frames++;
+
+		// Update HUD once per second
+		if (hud_last_update == 0) hud_last_update = now;
+		if (now - hud_last_update >= 1000.0) {
+			double speed_pct = (real_frames / 60.0) * 100.0;
+			EM_ASM({
+				var el = document.getElementById('fc-hud');
+				if (!el) {
+					el = document.createElement('div');
+					el.id = 'fc-hud';
+					el.style.cssText = 'position:fixed;top:8px;left:8px;z-index:99999;'
+						+ 'background:rgba(0,0,0,0.7);color:#fff;font:12px monospace;'
+						+ 'padding:4px 8px;pointer-events:none;border-radius:3px;';
+					document.body.appendChild(el);
+				}
+				el.textContent = 'FPS:' + $0 + ' Skip:' + $1 + ' Speed:' + $2.toFixed(0) + '%';
+			}, real_frames, skipped_frames, speed_pct);
+			real_frames = 0;
+			skipped_frames = 0;
+			hud_last_update = now;
+		}
+	}
+#endif
+
 	bool updated = false;
 	if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE, &updated) && updated)
 		update_variables(false);
@@ -1275,6 +1339,22 @@ void retro_run()
 		environ_cb(RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO, &avinfo);
 	}
 
+#ifdef __EMSCRIPTEN__
+	{
+		static int videocb_count = 0;
+		static int first_non_dupe = 0;
+		videocb_count++;
+		if (!is_dupe && first_non_dupe == 0) {
+			first_non_dupe = videocb_count;
+			EM_ASM({ console.log('[retro] FIRST REAL FRAME at video_cb #' + $0 + ' w=' + $1 + ' h=' + $2); },
+				videocb_count, framebufferWidth, framebufferHeight);
+		}
+		if (videocb_count <= 5 || (videocb_count % 10) == 0) {
+			EM_ASM({ console.log('[retro] video_cb #' + $0 + ': is_dupe=' + $1 + ' w=' + $2 + ' h=' + $3); },
+				videocb_count, is_dupe ? 1 : 0, framebufferWidth, framebufferHeight);
+		}
+	}
+#endif
 	video_cb(is_dupe ? 0 : RETRO_HW_FRAME_BUFFER_VALID, framebufferWidth, framebufferHeight, 0);
 
 	if (!config::ThreadedRendering || config::LimitFPS)
@@ -3579,24 +3659,30 @@ static void retro_keyboard_event(bool down, unsigned keycode, uint32_t character
 
 void fatal_error(const char* text, ...)
 {
+	va_list args;
+	char temp[2048];
+	va_start(args, text);
+	vsprintf(temp, text, args);
+	va_end(args);
+	strcat(temp, "\n");
 	if (log_cb)
-	{
-		va_list args;
-		char temp[2048];
-		va_start(args, text);
-		vsprintf(temp, text, args);
-		va_end(args);
-		strcat(temp, "\n");
 		log_cb(RETRO_LOG_ERROR, temp);
-	}
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.error('[FATAL] ' + UTF8ToString($0)); }, temp);
+#endif
 }
 
 [[noreturn]] void os_DebugBreak()
 {
 	ERROR_LOG(COMMON, "DEBUGBREAK!");
+#ifdef __EMSCRIPTEN__
+	EM_ASM({ console.error('[os_DebugBreak] called! Stack: ' + new Error().stack); });
+#endif
 	//exit(-1);
 #ifdef __SWITCH__
 	svcExitProcess();
+#elif defined(__EMSCRIPTEN__)
+	abort();
 #else
 	__builtin_trap();
 #endif
